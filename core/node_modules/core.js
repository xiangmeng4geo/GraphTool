!function(){
	var path = require('path'),
		fs = require('fs'),
		os = require('os'),
		crypto = require('crypto');

	var basepath = path.join(__dirname,'..');

	var currentPath = process.cwd(),
		tempPath = os.tmpdir();

	var SUFFIX_JSON = '.json',
		SUFFIF_PNG = '.png';

	var is_develop = path.dirname(currentPath) != tempPath;
	var project_path = is_develop? path.dirname(basepath): path.dirname(process.execPath);// 指向core所在目录或.exe所在目录
	var corePath = is_develop? basepath: path.dirname(process.execPath);
	/*得到源码根目录(打包运行时得到的是程序所在目录，开发环境下得到是源码的根目录)*/
	exports.getCorePath = function(){
		return corePath;
	}

	var path_conf_sys = path.join(corePath,'conf'),
		path_conf_project = path.join(project_path,'conf');
	function getConf(name){
		return getConfJson(path.join(path_conf_sys,name+SUFFIX_JSON));
	}
	var conf = {};
	['Sys','Verification'].forEach(function(v,i){
		conf['get'+v] = function(){
			return getConf(v.toLowerCase());
		}
	});
	function writeFile(filepath,content){
		fs.writeFileSync(filepath,content);
		delete require.cache[filepath];
	}
	function getConfJson(filepath){
		if(fs.existsSync(filepath)){
			return require(filepath);
		}
		return null
	}
	conf.write = function(name,content){
		return writeFile(path.join(path_conf_sys,name+SUFFIX_JSON),content);
	}
	conf.get = getConf;
	conf.User = {
		get: function(name){
			return getConfJson(path.join(path_conf_project,name+SUFFIX_JSON));
		},
		write: function(name,content,is_object){
			if(is_object){
				content = JSON.stringify(content);
			}
			return writeFile(path.join(path_conf_project,name+SUFFIX_JSON),content);
		}
	}

	var util = {};
	/*加密字符串*/
	util.encrypt = function (str,private_key){
	    if(str && str.toString){
	        return crypto.createHash('sha1').update(str.toString()+(private_key||'util')).digest('hex');
	    }
	    return '';
	}
	!function(){
		// 同步新建目录
		function mkdirSync(mkPath){
			try{
				var parentPath = path.dirname(mkPath);
				if(!fs.existsSync(parentPath)){
					mkdirSync(parentPath);
				}
				if(!fs.existsSync(mkPath)){
					fs.mkdirSync(mkPath);
				}
				return true;
			}catch(e){}
		}
		// 同步拷贝文件
		function copySync(fromPath,toPath){
			try{
				if(fs.existsSync(toPath)){
					fs.unlinkSync(toPath);
				}else{
					mkdirSync(path.dirname(toPath));
				}
				var BUF_LENGTH = 64*1024
				var buff = new Buffer(BUF_LENGTH)
				var fdr = fs.openSync(fromPath, 'r');
				var fdw = fs.openSync(toPath, 'w');
				var bytesRead = 1;
				var pos = 0;
				while (bytesRead > 0){
					bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
					fs.writeSync(fdw,buff,0,bytesRead);
					pos += bytesRead;
				}
				
				fs.closeSync(fdr);
				fs.closeSync(fdw);
				return true;
			}catch(e){}
		}

		// 遍历目录
		function readdir(dir,attr){
			attr || (attr = {});
			var is_not_recursive = attr.is_not_recursive;
			if(fs.existsSync(dir)){
				var stat = fs.statSync(dir);
				if(stat.isDirectory()){
					var return_val = [];
					var files = fs.readdirSync(dir);
					var is_mtime = attr.mtime;
    				files.sort().forEach(function(file) {
    					var fullName = path.join(dir, file);
    					var stat_file = fs.statSync(fullName);
    					var isDir = stat_file.isDirectory();
    					var obj = {name: fullName};
    					if(is_mtime){
    						obj.mtime = stat_file.mtime;
    					}
    					if (isDir && !is_not_recursive) {
    						obj.sub = readdir(fullName);
    					}
    					return_val.push(obj);
    				});
    				return return_val;
				}
			}
		}
		function rmfileSync(p) {
		    //如果文件路径不存在或文件路径不是文件夹则直接返回
		    try{
		    	if(fs.existsSync(p)){
			    	var stat = fs.statSync(p);
			    	if(stat.isDirectory()){
			    		var files = fs.readdirSync(p);
			    		files.forEach(function(file) {
				            var fullName = path.join(p, file);
				            if (fs.statSync(fullName).isDirectory()) {
				                rmfileSync(fullName);
				            } else {
				                fs.unlinkSync(fullName);
				            }
				        });
					    fs.rmdirSync(p);
			    	}else{
			    		fs.unlinkSync(p);
			    	}
			    }
		    	return true;
		    }catch(e){}
		}
		function readFile(file,is_return_json){
			try{
				if(fs.existsSync(file)){
					var content = fs.readFileSync(file);
					return is_return_json? JSON.parse(content): content;
				}
			}catch(e){}
		}
		var file_path = {
			icon: path.join(project_path,'image/icon'),
			image: path.join(project_path,'image/bg'),
			tmp: path.join(project_path,'tmp')
		}

		// 创建所需目录
		for(var i in file_path){
			mkdirSync(file_path[i]);
		}
		var file = {
			readdir: readdir,
			copy: copySync,
			mkdir: mkdirSync,
			rm: rmfileSync,
			path: file_path,
			exists: fs.existsSync,
			readFile: readFile,
			stat: fs.statSync,
			write: writeFile
		};
		util.file = file;
	}();
	
	!function(){
		// getNewest('/a/b','2014-10-21','2014-10-21');
		// getNewest('/a/b',2);
		var file_util = util.file;
		function getNewest(dir,rule){
			var files_obj = file_util.readdir(dir,{mtime: true, is_not_recursive: true});
			var files = [];
			files_obj = files_obj.sort(function(a,b){
				return a.mtime < b.mtime;
			}).filter(function(v){
				if(!v.sub){
					return v;// 只使用文件
				}
			});
			var time_start,time_end;
			var args = arguments;
			var file;
			if(args.length == 3){
				var days = args[2];
				time_end = new Date();
				time_start = new Date();
				time_start.setDate(time_start.getDate()-days);
			}else{
				time_start = new Date(args[2]),
				time_end = new Date(args[3]);
			}
			rule = rule.replace(/y{2,}|M{2,}|d{2,}|h{2,}|m{2,}|s{2,}|q{2,}|S{2,}/g, function(sub){
				return '\\d{'+sub.length+'}';
			});
			rule = rule.replace(/yMdhmsqS/g,'\\w');
			rule = rule.replace(/\./g,'\\.');
			rule = new RegExp('^'+rule+'$');
			// console.log(files_obj,rule,time_start,time_end);
			for(var i = 0,j = files_obj.length;i<j;i++){
				var _f = files_obj[i];
				var _mtime = _f.mtime;
				if(_mtime >= time_start && _mtime <= time_end){
					var file_path = _f.name;
					var basename = path.basename(file_path);

					// console.log(basename,rule.test(basename));
					if(rule.test(basename)){
						return file_path;
					}
				}
			}
		}
		file_util.micaps = {
			getNewest: getNewest
		}
		function getTmpLegendPath(product_name){
			return path.join(file_util.path.tmp, product_name+SUFFIF_PNG);;
		}
		function getUserConfPath(product_name){
			return path.join(path_conf_project, product_name+SUFFIX_JSON);;
		}
		function isNew(product_name){
			var img_path = getTmpLegendPath(product_name);
			var conf_path = getUserConfPath(product_name);
			return (fs.existsSync(img_path) && fs.existsSync(conf_path) && fs.statSync(img_path).mtime > fs.statSync(conf_path).mtime);
		}
		function saveBase64(save_file_name, img_data){
			img_data = img_data.substring(img_data.indexOf('base64,')+7);
			img_data = new Buffer(img_data, 'base64');
			writeFile(save_file_name, img_data);
		}
		file_util.img = {
			saveBase64: saveBase64
		}
		file_util.tmp = {
			legend: {
				getPath: getTmpLegendPath,
				isNew: isNew,
				save: saveBase64
			}
		}
	}();
	util.path = path;
	// util.writeFile = writeFile;
	exports.util = util;
	exports.conf = conf;
}();