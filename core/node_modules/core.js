!function(){
	var path = require('path'),
		fs = require('fs'),
		os = require('os'),
		crypto = require('crypto'),
		_isArray = require('util').isArray;

	var parse_micaps = require('./micaps_parser/parser').parse;
	var raster2vector = require('./micaps_parser/utils/raster2vector').raster2vector;

	var basepath = path.join(__dirname,'..');

	var currentPath = process.cwd(),
		tempPath = os.tmpdir();

	var SUFFIX_JSON = '.json',
		SUFFIF_PNG = '.png';

	var is_develop = path.dirname(currentPath) != tempPath;
	var project_path = is_develop? path.dirname(basepath): path.dirname(process.execPath);// 指向core所在目录或.exe所在目录
	var core_path = is_develop? basepath: path.dirname(process.execPath);
	/*得到源码根目录(打包运行时得到的是程序所在目录，开发环境下得到是源码的根目录)*/
	// exports.getCorePath = function(){
	// 	return core_path;
	// }
	function _isPlainObject(obj){
		if(({}).toString.call(obj) == '[object Object]' && !(obj.constructor && !obj.constructor.prototype.hasOwnProperty('isPrototypeOf'))){
			return true;
		}
	}
	function _isFunction(fn){
		return ({}).toString.call(fn) == '[object Function]' ;
	}
	function _extend(){
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !_isFunction(target) ) {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( _isPlainObject(copy) || (copyIsArray = _isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && _isArray(src) ? src : [];

						} else {
							clone = src && _isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = _extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	}
	/*时间格式化*/
	Date.prototype.format = function(format,is_not_second){
		format || (format = 'yyyy-MM-dd hh:mm:ss');
		var o = {
			"M{2}" : this.getMonth()+1, //month
			"d{2}" : this.getDate(),    //day
			"h{2}" : this.getHours(),   //hour
			"m{2}" : this.getMinutes(), //minute
			"q{2}" : Math.floor((this.getMonth()+3)/3),  //quarter
		}
		if(!is_not_second){
			o["s{2}"] = this.getSeconds(); //second
			o["S{2}"] = this.getMilliseconds() //millisecond
		}
		if(/(y{4}|y{2})/.test(format)){
			format = format.replace(RegExp.$1,(this.getFullYear()+"").substr(4 - RegExp.$1.length));
		} 
		for(var k in o){
			if(new RegExp("("+ k +")").test(format)){
				format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :("00"+ o[k]).substr((""+ o[k]).length));
			}
		}
		
		return format;
	}
	var path_conf_sys = path.join(core_path,'conf'),
		path_conf_project = path.join(project_path,'conf');
	function getConf(name, is_force){
		return getConfJson(path.join(path_conf_sys,name+SUFFIX_JSON), is_force);
	}
	var conf = {};
	['Sys','Verification'].forEach(function(v,i){
		conf['get'+v] = function(){
			return getConf(v.toLowerCase(), i == 1);
		}
	});
	conf.setVerification = function(l){
		var obj = conf.getVerification();
		obj.l = l;
		conf.write('Verification', JSON.stringify(obj));
	}
	function writeFile(filepath,content){
		fs.writeFileSync(filepath, content);
		delete require.cache[filepath];
	}
	function getConfJson(filepath, is_force){
		if(fs.existsSync(filepath)){
			if(is_force){
				delete require.cache[filepath];
			}
			
			return require(filepath);
		}
		return null
	}
	conf.write = function(name,content){
		return writeFile(path.join(path_conf_sys,name+SUFFIX_JSON),content);
	}
	var CONF_FILE_NAME_SYS = '系统';
	var CONF_FILE_NAME_SYS_PRODUCT_TREE = 'sys_product_tree';
	conf.get = getConf;
	function _getConfPath(name){
		return path.join(path_conf_project, name+SUFFIX_JSON);
	}
	conf.User = {
		getPath: _getConfPath,
		getSys: function(){
			return this.get(CONF_FILE_NAME_SYS);
		},
		getTree: function(){
			var conf_user_path = _getConfPath(CONF_FILE_NAME_SYS_PRODUCT_TREE);
			return getConfJson(conf_user_path);
		},
		setTree: function(treeData){
			this.write(CONF_FILE_NAME_SYS_PRODUCT_TREE, treeData);
		},
		get: function(name){
			var conf_user_path = _getConfPath(name);
			var conf_user = getConfJson(conf_user_path);
			var conf_sys_path = path.join(path_conf_project, CONF_FILE_NAME_SYS+SUFFIX_JSON);
			if(conf_sys_path != conf_user_path){
				var conf_sys = getConfJson(conf_sys_path);
				if(conf_sys){
					if(!conf_user){
						conf_user = {
							other: {}
						};
					}
					if(!conf_user.other.logo && conf_sys.logos.company.flag){
						conf_user.other.logo = conf_sys.logos.company.p;
					}
					conf_user.other.logo_southsea = conf_sys.logos.southsea; // 添加南海logo
					conf_user.projector = conf_sys.projector; //添加地图投影
				}
			}
			return conf_user;
		},
		write: function(name,content,is_object){
			if(is_object){
				content = JSON.stringify(content);
			}
			return writeFile(path.join(path_conf_project,name+SUFFIX_JSON),content);
		},
		rename: function(name_old, name_new){
			var path_old = _getConfPath(name_old),
				path_new = _getConfPath(name_new);
			try{
				fs.renameSync(path_old, path_new);
			}catch(e){}
		}
	}

	var util = {};
	/*加密字符串*/
	var encrypt = function (str,private_key){
	    if(str && str.toString){
	        return crypto.createHash('sha1').update(str.toString()+(private_key||'util')).digest('hex');
	    }
	    return '';
	}
	/*可逆加密解密 http://blog.fens.me/nodejs-crypto/*/
	var METHOD_ALGORITHM = 'aes-256-cbc',
		DEFAULT_KEY = 'GraphTool';
	encrypt.encode = function(str, private_key){
		var cip = crypto.createCipher(METHOD_ALGORITHM, private_key||DEFAULT_KEY);
		return cip.update(str, 'binary', 'hex') + cip.final('hex');
	}
	encrypt.decode = function(str, private_key){
		var decipher = crypto.createDecipher(METHOD_ALGORITHM, private_key||DEFAULT_KEY);
		try{
			return decipher.update(str, 'hex', 'binary') + decipher.final('binary');
		}catch(e){
			// console.log(str, e.stack);
		}
	}
	util.encrypt = encrypt;
	!function(){
		// 同步新建目录
		function mkdirSync(mkPath){
			try{
				var parentPath = path.dirname(mkPath);
				if(!fs.existsSync(parentPath)){
					mkdirSync(parentPath);
				}
				if(!fs.existsSync(mkPath)){
					fs.mkdirSync(mkPath);
				}
				return true;
			}catch(e){}
		}
		// 同步拷贝文件
		function copySync(fromPath,toPath){
			try{
				if(fs.existsSync(toPath)){
					fs.unlinkSync(toPath);
				}else{
					mkdirSync(path.dirname(toPath));
				}
				var BUF_LENGTH = 64*1024
				var buff = new Buffer(BUF_LENGTH)
				var fdr = fs.openSync(fromPath, 'r');
				var fdw = fs.openSync(toPath, 'w');
				var bytesRead = 1;
				var pos = 0;
				while (bytesRead > 0){
					bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
					fs.writeSync(fdw,buff,0,bytesRead);
					pos += bytesRead;
				}
				
				fs.closeSync(fdr);
				fs.closeSync(fdw);
				return true;
			}catch(e){}
		}

		// 遍历目录
		function readdir(dir,attr){
			attr || (attr = {});
			var is_not_recursive = attr.is_not_recursive;
			if(fs.existsSync(dir)){
				var stat = fs.statSync(dir);
				if(stat.isDirectory()){
					var return_val = [];
					var files = fs.readdirSync(dir);
					var is_mtime = attr.mtime;
    				files.sort().forEach(function(file) {
    					var fullName = path.join(dir, file);
    					var stat_file = fs.statSync(fullName);
    					var isDir = stat_file.isDirectory();
    					var obj = {name: fullName};
    					if(is_mtime){
    						obj.mtime = stat_file.mtime;
    					}
    					if (isDir && !is_not_recursive) {
    						obj.sub = readdir(fullName);
    					}
    					return_val.push(obj);
    				});
    				return return_val;
				}
			}
		}
		function rmfileSync(p) {
		    //如果文件路径不存在或文件路径不是文件夹则直接返回
		    try{
		    	if(fs.existsSync(p)){
			    	var stat = fs.statSync(p);
			    	if(stat.isDirectory()){
			    		var files = fs.readdirSync(p);
			    		files.forEach(function(file) {
				            var fullName = path.join(p, file);
				            if (fs.statSync(fullName).isDirectory()) {
				                rmfileSync(fullName);
				            } else {
				                fs.unlinkSync(fullName);
				            }
				        });
					    fs.rmdirSync(p);
			    	}else{
			    		fs.unlinkSync(p);
			    	}
			    }
		    	return true;
		    }catch(e){}
		}
		function readFile(file,is_return_json){
			try{
				if(fs.existsSync(file)){
					var content = fs.readFileSync(file);
					return is_return_json? JSON.parse(content): content;
				}
			}catch(e){}
		}
		var _path_tmp = path.join(project_path,'tmp');
		var file_path = {
			project: project_path,
			core: core_path,
			icon: path.join(project_path,'image/icon'),
			image: path.join(project_path,'image/bg'),
			tmp: _path_tmp,
			tmp_micaps: path.join(_path_tmp, 'micaps'),
			tmp_legend: path.join(_path_tmp, 'legend'),
			doc: path.join(core_path, 'doc/help.chm')
		}

		// 创建所需目录
		for(var i in file_path){
			mkdirSync(file_path[i]);
		}
		var file = {
			readdir: readdir,
			copy: copySync,
			mkdir: mkdirSync,
			rm: rmfileSync,
			path: file_path,
			exists: fs.existsSync,
			readFile: readFile,
			stat: fs.statSync,
			write: writeFile,
			getJson: function(_path, callback){
				var data = getConfJson(_path);
				callback && callback(data);
			}
		};
		util.file = file;
	}();
	
	!function(){
		// getNewest('/a/b','2014-10-21','2014-10-21');
		// getNewest('/a/b',2);
		var file_util = util.file;
		function getNewest(dir, rule){
			var time_start,time_end;
			var args = arguments;
			var file;
			if(args.length == 3){
				var days = args[2];
				time_end = new Date();
				time_start = new Date();
				time_start.setDate(time_start.getDate()-days);
			}else{
				time_start = new Date(args[2]),
				time_end = new Date(args[3]);
			}

			for(; time_start <= time_end;){
				var file_name = time_end.format(rule);
				var file_path = path.join(dir, file_name);
				if(file_util.exists(file_path)){
					var mtime = fs.statSync(file_path).mtime;
					if(mtime >= time_start){
						return file_path;
					}
				}
				time_end.setDate(time_end.getDate() - 1);
			}
		}

		/*得到micaps文件内容，没有缓存的解析完成后保存*/
		function _getMicapsData(file_path, option, callback){
			// 多条件缓存，防止文件时间不变但生成条件变时数据不更新问题
			var cache_file = path.join(file_util.path.tmp_micaps, encrypt(file_path + JSON.stringify(option)));
			if(fs.existsSync(cache_file) && fs.statSync(cache_file).mtime > fs.statSync(file_path).mtime){
				callback && callback(null, file_util.readFile(cache_file, true), {
					path: cache_file,
					iscache: true
				});
			}else{
				parse_micaps(file_path, option, function(err, data){
					if(err){
						data = file_util.readFile(file_path, true);
						if(data){
							err = data.type? null: {
								code: 101
							};
						}
					}
					if(data){
						fs.writeFileSync(cache_file, JSON.stringify(data)); //异步保存数据
					}
					callback && callback(err, data, {
						path: cache_file
					});
				});
			}
		}
		var _raster2vector = function(data, color_novalue, params){
			var cache_file_micaps = (params? params.path: null) || null;
			var cache_file = cache_file_micaps ? path.join(file_util.path.tmp_micaps, encrypt('raster2vector_'+color_novalue+'_'+cache_file_micaps)): null;

			if(cache_file && cache_file_micaps && 
				fs.existsSync(cache_file) && fs.existsSync(cache_file_micaps) && 
				fs.statSync(cache_file).mtime >= fs.statSync(cache_file_micaps).mtime
			){
				return file_util.readFile(cache_file, true);
			}else{
				var data = raster2vector(data, color_novalue);
				if(cache_file){
					fs.writeFileSync(cache_file, JSON.stringify(data)); //异步保存数据
				}
				return data;
			}
		}
		file_util.micaps = {
			getNewest: getNewest,
			getData: _getMicapsData,
			raster2vector: _raster2vector
		}
		function getTmpLegendPath(product_name, width, height){
			return path.join(file_util.path.tmp_legend, product_name+'_'+width+'x'+height+SUFFIF_PNG);;
		}
		function getUserConfPath(product_name){
			return path.join(path_conf_project, product_name+SUFFIX_JSON);;
		}
		function isNew(product_name, width, height){
			var img_path = getTmpLegendPath(product_name, width, height);
			var conf_path = getUserConfPath(product_name);
			return (fs.existsSync(img_path) && fs.existsSync(conf_path) && fs.statSync(img_path).mtime > fs.statSync(conf_path).mtime);
		}
		function saveBase64(save_file_name, img_data){
			img_data = img_data.substring(img_data.indexOf('base64,')+7);
			img_data = new Buffer(img_data, 'base64');
			writeFile(save_file_name, img_data);
		}
		file_util.img = {
			saveBase64: saveBase64
		}
		file_util.tmp = {
			legend: {
				getPath: getTmpLegendPath,
				isNew: isNew,
				save: saveBase64
			}
		}
	}();

	// // var gui = require('nw.gui');
	// var _doc_path = path.join(core_path, 'doc/help.chm');
	// var _open = function(_file_path){
	// 	gui.Shell.openItem(_file_path || _doc_path);
	// }
	// util.open = _open;
	util.path = path;
	// util.writeFile = writeFile;
	exports.util = util;
	exports.conf = conf;
}();