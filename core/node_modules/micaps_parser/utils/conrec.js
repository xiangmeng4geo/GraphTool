/**
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://paulbourke.net/papers/conrec for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */
!function(){
  var Conrec = (function() {
    var EPSILON = 1e-20;

    var pointsEqual = function(a, b) {
      var x = a.x - b.x, y = a.y - b.y;
      return x * x + y * y < EPSILON;
    }

    var reverseList = function(list) {
      var pp = list.head;

      while (pp) {
        // swap prev/next pointers
        var temp = pp.next;
        pp.next = pp.prev;
        pp.prev = temp;

        // continue through the list
        pp = temp;
      }

      // swap head/tail pointers
      var temp = list.head;
      list.head = list.tail;
      list.tail = temp;
    }

    var ContourBuilder = function(level) {
      this.level = level;
      this.s = null;
      this.count = 0;
    }
    ContourBuilder.prototype.remove_seq = function(list) {
      // if list is the first item, static ptr s is updated
      if (list.prev) {
        list.prev.next = list.next;
      } else {
        this.s = list.next;
      }

      if (list.next) {
        list.next.prev = list.prev;
      }
      --this.count;
    }
    ContourBuilder.prototype.addSegment = function(a, b) {
      var ss = this.s;
      var ma = null;
      var mb = null;
      var prependA = false;
      var prependB = false;

      while (ss) {
        if (ma == null) {
          // no match for a yet
          if (pointsEqual(a, ss.head.p)) {
            ma = ss;
            prependA = true;
          } else if (pointsEqual(a, ss.tail.p)) {
            ma = ss;
          }
        }
        if (mb == null) {
          // no match for b yet
          if (pointsEqual(b, ss.head.p)) {
            mb = ss;
            prependB = true;
          } else if (pointsEqual(b, ss.tail.p)) {
            mb = ss;
          }
        }
        // if we matched both no need to continue searching
        if (mb != null && ma != null) {
          break;
        } else {
          ss = ss.next;
        }
      }

      // c is the case selector based on which of ma and/or mb are set
      var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);

      switch(c) {
        case 0:   // both unmatched, add as new sequence
          var aa = {p: a, prev: null};
          var bb = {p: b, next: null};
          aa.next = bb;
          bb.prev = aa;

          // create sequence element and push onto head of main list. The order
          // of items in this list is unimportant
          ma = {head: aa, tail: bb, next: this.s, prev: null, closed: false};
          if (this.s) {
            this.s.prev = ma;
          }
          this.s = ma;

          ++this.count;    // not essential - tracks number of unmerged sequences
        break;

        case 1:   // a matched, b did not - thus b extends sequence ma
          var pp = {p: b};

          if (prependA) {
            pp.next = ma.head;
            pp.prev = null;
            ma.head.prev = pp;
            ma.head = pp;
          } else {
            pp.next = null;
            pp.prev = ma.tail;
            ma.tail.next = pp;
            ma.tail = pp;
          }
        break;

        case 2:   // b matched, a did not - thus a extends sequence mb
          var pp = {p: a};

          if (prependB) {
            pp.next = mb.head;
            pp.prev = null;
            mb.head.prev = pp;
            mb.head = pp;
          } else {
            pp.next = null;
            pp.prev = mb.tail;
            mb.tail.next = pp;
            mb.tail = pp;
          }
        break;

        case 3:   // both matched, can merge sequences
          // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)

          if (ma === mb) {
            var pp = {p: ma.tail.p, next: ma.head, prev: null};
            ma.head.prev = pp;
            ma.head = pp;
            ma.closed = true;
            break;
          }

          // there are 4 ways the sequence pair can be joined. The current setting of prependA and
          // prependB will tell us which type of join is needed. For head/head and tail/tail joins
          // one sequence needs to be reversed
          switch((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
            case 0:   // tail-tail
              // reverse ma and append to mb
              reverseList(ma);
              // fall through to head/tail case
            case 1:   // head-tail
              // ma is appended to mb and ma discarded
              mb.tail.next = ma.head;
              ma.head.prev = mb.tail;
              mb.tail = ma.tail;

              //discard ma sequence record
              this.remove_seq(ma);
            break;

            case 3:   // head-head
              // reverse ma and append mb to it
              reverseList(ma);
              // fall through to tail/head case
            case 2:   // tail-head
              // mb is appended to ma and mb is discarded
              ma.tail.next = mb.head;
              mb.head.prev = ma.tail;
              ma.tail = mb.tail;

              //discard mb sequence record
              this.remove_seq(mb);
          break;
        }
      }
    }

    /**
     * Implements CONREC.
     *
     * @param {function} drawContour function for drawing contour.  Defaults to a
     *                               custom "contour builder", which populates the
     *                               contours property.
     */
    var Conrec = function(drawContour) {
      if (!drawContour) {
        var c = this;
        c.contours = {};
        /**
         * drawContour - interface for implementing the user supplied method to
         * render the countours.
         *
         * Draws a line between the start and end coordinates.
         *
         * @param startX    - start coordinate for X
         * @param startY    - start coordinate for Y
         * @param endX      - end coordinate for X
         * @param endY      - end coordinate for Y
         * @param contourLevel - Contour level for line.
         */
        this.drawContour = function(startX, startY, endX, endY, contourLevel, k) {
          var cb = c.contours[k];
          if (!cb) {
            cb = c.contours[k] = new ContourBuilder(contourLevel);
          }
          cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});
        }
        this.contourList = function() {
          var l = [];
          var a = c.contours;
          for (var k in a) {
            var s = a[k].s;
            var level = a[k].level;
            while (s) {
              var h = s.head;
              var l2 = [];
              l2.level = level;
              l2.k = k;
              while (h && h.p) {
                l2.push(h.p);
                h = h.next;
              }
              l.push(l2);
              s = s.next;
            }
          }
          l.sort(function(a, b) { return b.k - a.k });
          return l;
        }
      } else {
        this.drawContour = drawContour;
      }
      this.h  = new Array(5);
      this.sh = new Array(5);
      this.xh = new Array(5);
      this.yh = new Array(5);
    }

    /**
     * contour is a contouring subroutine for rectangularily spaced data
     *
     * It emits calls to a line drawing subroutine supplied by the user which
     * draws a contour map corresponding to real*4data on a randomly spaced
     * rectangular grid. The coordinates emitted are in the same units given in
     * the x() and y() arrays.
     *
     * Any number of contour levels may be specified but they must be in order of
     * increasing value.
     *
     *
     * @param {number[][]} d - matrix of data to contour
     * @param {number} ilb,iub,jlb,jub - index bounds of data matrix
     *
     *             The following two, one dimensional arrays (x and y) contain
     *             the horizontal and vertical coordinates of each sample points.
     * @param {number[]} x  - data matrix column coordinates
     * @param {number[]} y  - data matrix row coordinates
     * @param {number} nc   - number of contour levels
     * @param {number[]} z  - contour levels in increasing order.
     */
    Conrec.prototype.contour = function(d, ilb, iub, jlb, jub, x, y, nc, z) {
      var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
      var drawContour = this.drawContour;
      this.contours = {};

      /** private */
      var xsect = function(p1, p2){
        return (h[p2]*xh[p1]-h[p1]*xh[p2])/(h[p2]-h[p1]);
      }

      var ysect = function(p1, p2){
        return (h[p2]*yh[p1]-h[p1]*yh[p2])/(h[p2]-h[p1]);
      }
      var m1;
      var m2;
      var m3;
      var case_value;
      var dmin;
      var dmax;
      var x1 = 0.0;
      var x2 = 0.0;
      var y1 = 0.0;
      var y2 = 0.0;

      // The indexing of im and jm should be noted as it has to start from zero
      // unlike the fortran counter part
      var im = [0, 1, 1, 0];
      var jm = [0, 0, 1, 1];

      // Note that castab is arranged differently from the FORTRAN code because
      // Fortran and C/C++ arrays are transposed of each other, in this case
      // it is more tricky as castab is in 3 dimensions
      var castab = [
        [
          [0, 0, 8], [0, 2, 5], [7, 6, 9]
        ],
        [
          [0, 3, 4], [1, 3, 1], [4, 3, 0]
        ],
        [
          [9, 6, 7], [5, 2, 0], [8, 0, 0]
        ]
      ];

      for (var j=(jub-1);j>=jlb;j--) {
        for (var i=ilb;i<=iub-1;i++) {
          var temp1, temp2;
          temp1 = Math.min(d[i][j],d[i][j+1]);
          temp2 = Math.min(d[i+1][j],d[i+1][j+1]);
          dmin  = Math.min(temp1,temp2);
          temp1 = Math.max(d[i][j],d[i][j+1]);
          temp2 = Math.max(d[i+1][j],d[i+1][j+1]);
          dmax  = Math.max(temp1,temp2);

          if (dmax>=z[0]&&dmin<=z[nc-1]) {
            for (var k=0;k<nc;k++) {
              if (z[k]>=dmin&&z[k]<=dmax) {
                for (var m=4;m>=0;m--) {
                  if (m>0) {
                    // The indexing of im and jm should be noted as it has to
                    // start from zero
                    h[m] = d[i+im[m-1]][j+jm[m-1]]-z[k];
                    xh[m] = x[i+im[m-1]];
                    yh[m] = y[j+jm[m-1]];
                  } else {
                    h[0] = 0.25*(h[1]+h[2]+h[3]+h[4]);
                    xh[0]=0.5*(x[i]+x[i+1]);
                    yh[0]=0.5*(y[j]+y[j+1]);
                  }
                  if (h[m]>0.0) {
                    sh[m] = 1;
                  } else if (h[m]<0.0) {
                    sh[m] = -1;
                  } else
                    sh[m] = 0;
                }
                //
                // Note: at this stage the relative heights of the corners and the
                // centre are in the h array, and the corresponding coordinates are
                // in the xh and yh arrays. The centre of the box is indexed by 0
                // and the 4 corners by 1 to 4 as shown below.
                // Each triangle is then indexed by the parameter m, and the 3
                // vertices of each triangle are indexed by parameters m1,m2,and
                // m3.
                // It is assumed that the centre of the box is always vertex 2
                // though this isimportant only when all 3 vertices lie exactly on
                // the same contour level, in which case only the side of the box
                // is drawn.
                //
                //
                //      vertex 4 +-------------------+ vertex 3
                //               | \               / |
                //               |   \    m-3    /   |
                //               |     \       /     |
                //               |       \   /       |
                //               |  m=2    X   m=2   |       the centre is vertex 0
                //               |       /   \       |
                //               |     /       \     |
                //               |   /    m=1    \   |
                //               | /               \ |
                //      vertex 1 +-------------------+ vertex 2
                //
                //
                //
                //               Scan each triangle in the box
                //
                for (m=1;m<=4;m++) {
                  m1 = m;
                  m2 = 0;
                  if (m!=4) {
                      m3 = m+1;
                  } else {
                      m3 = 1;
                  }
                  case_value = castab[sh[m1]+1][sh[m2]+1][sh[m3]+1];
                  if (case_value!=0) {
                    switch (case_value) {
                      case 1: // Line between vertices 1 and 2
                        x1=xh[m1];
                        y1=yh[m1];
                        x2=xh[m2];
                        y2=yh[m2];
                        break;
                      case 2: // Line between vertices 2 and 3
                        x1=xh[m2];
                        y1=yh[m2];
                        x2=xh[m3];
                        y2=yh[m3];
                        break;
                      case 3: // Line between vertices 3 and 1
                        x1=xh[m3];
                        y1=yh[m3];
                        x2=xh[m1];
                        y2=yh[m1];
                        break;
                      case 4: // Line between vertex 1 and side 2-3
                        x1=xh[m1];
                        y1=yh[m1];
                        x2=xsect(m2,m3);
                        y2=ysect(m2,m3);
                        break;
                      case 5: // Line between vertex 2 and side 3-1
                        x1=xh[m2];
                        y1=yh[m2];
                        x2=xsect(m3,m1);
                        y2=ysect(m3,m1);
                        break;
                      case 6: //  Line between vertex 3 and side 1-2
                        x1=xh[m3];
                        y1=yh[m3];
                        x2=xsect(m1,m2);
                        y2=ysect(m1,m2);
                        break;
                      case 7: // Line between sides 1-2 and 2-3
                        x1=xsect(m1,m2);
                        y1=ysect(m1,m2);
                        x2=xsect(m2,m3);
                        y2=ysect(m2,m3);
                        break;
                      case 8: // Line between sides 2-3 and 3-1
                        x1=xsect(m2,m3);
                        y1=ysect(m2,m3);
                        x2=xsect(m3,m1);
                        y2=ysect(m3,m1);
                        break;
                      case 9: // Line between sides 3-1 and 1-2
                        x1=xsect(m3,m1);
                        y1=ysect(m3,m1);
                        x2=xsect(m1,m2);
                        y2=ysect(m1,m2);
                        break;
                      default:
                        break;
                    }
                    // Put your processing code here and comment out the printf
                    //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                    drawContour(x1,y1,x2,y2,z[k],k);
                  }
                }
              }
            }
          }
        }
      }
    }
    return Conrec;
  })();

  function sortEsc(arr){
    arr.sort(function(a, b){
      return a - b;
    });
  }
  function sortDesc(arr){
    arr.sort(function(a, b){
      return b - a;
    });
  }
  //面积为正可以判断多边型正面，面积为负表示多边形背面
  function getArea(points){
    var S = 0;
    for(var i = 0, j = points.length - 1; i<j; i++){
      var p_a = points[i],
        p_b = points[i + 1];
      S += p_a.x * p_b.y - p_b.x*p_a.y;
    }
    var p_a = points[j],
      p_b = points[0];
    S += p_a.x * p_b.y - p_b.x*p_a.y;
    return S/2;
  }

  // B样条插值平滑算法
  var smoothBSpline = (function(){
    // https://github.com/Tagussan/BSpline
    var BSpline = function(points,degree,copy){
        if(copy){
            this.points = []
            for(var i = 0;i<points.length;i++){
                this.points.push(points[i]);
            }
        }else{
            this.points = points;
        }
        this.degree = degree;
        this.dimension = points[0].length;
        if(degree == 2){
            this.baseFunc = this.basisDeg2;
            this.baseFuncRangeInt = 2;
        }else if(degree == 3){
            this.baseFunc = this.basisDeg3;
            this.baseFuncRangeInt = 2;
        }else if(degree == 4){
            this.baseFunc = this.basisDeg4;
            this.baseFuncRangeInt = 3;
        }else if(degree == 5){
            this.baseFunc = this.basisDeg5;
            this.baseFuncRangeInt = 3;
        } 
    };

    BSpline.prototype.seqAt = function(dim){
        var points = this.points;
        var margin = this.degree + 1;
        return function(n){
            if(n < margin){
                return points[0][dim];
            }else if(points.length + margin <= n){
                return points[points.length-1][dim];
            }else{
                return points[n-margin][dim];
            }
        };
    };

    BSpline.prototype.basisDeg2 = function(x){
        if(-0.5 <= x && x < 0.5){
            return 0.75 - x*x;
        }else if(0.5 <= x && x <= 1.5){
            return 1.125 + (-1.5 + x/2.0)*x;
        }else if(-1.5 <= x && x < -0.5){
            return 1.125 + (1.5 + x/2.0)*x;
        }else{
            return 0;
        }
    };

    BSpline.prototype.basisDeg3 = function(x){
        if(-1 <= x && x < 0){
            return 2.0/3.0 + (-1.0 - x/2.0)*x*x;
        }else if(1 <= x && x <= 2){
            return 4.0/3.0 + x*(-2.0 + (1.0 - x/6.0)*x);
        }else if(-2 <= x && x < -1){
            return 4.0/3.0 + x*(2.0 + (1.0 + x/6.0)*x);
        }else if(0 <= x && x < 1){
            return 2.0/3.0 + (-1.0 + x/2.0)*x*x;
        }else{
            return 0;
        }
    };

    BSpline.prototype.basisDeg4 = function(x){
        if(-1.5 <= x && x < -0.5){
            return 55.0/96.0 + x*(-(5.0/24.0) + x*(-(5.0/4.0) + (-(5.0/6.0) - x/6.0)*x));
        }else if(0.5 <= x && x < 1.5){
            return 55.0/96.0 + x*(5.0/24.0 + x*(-(5.0/4.0) + (5.0/6.0 - x/6.0)*x));
        }else if(1.5 <= x && x <= 2.5){
            return 625.0/384.0 + x*(-(125.0/48.0) + x*(25.0/16.0 + (-(5.0/12.0) + x/24.0)*x));
        }else if(-2.5 <= x && x <= -1.5){
            return 625.0/384.0 + x*(125.0/48.0 + x*(25.0/16.0 + (5.0/12.0 + x/24.0)*x));
        }else if(-1.5 <= x && x < 1.5){
            return 115.0/192.0 + x*x*(-(5.0/8.0) + x*x/4.0);
        }else{
            return 0;
        }
    };

    BSpline.prototype.basisDeg5 = function(x){
        if(-2 <= x && x < -1){
            return 17.0/40.0 + x*(-(5.0/8.0) + x*(-(7.0/4.0) + x*(-(5.0/4.0) + (-(3.0/8.0) - x/24.0)*x)));
        }else if(0 <= x && x < 1){
            return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 - x/12.0)*x*x);
        }else if(2 <= x && x <= 3){
            return 81.0/40.0 + x*(-(27.0/8.0) + x*(9.0/4.0 + x*(-(3.0/4.0) + (1.0/8.0 - x/120.0)*x)));
        }else if(-3 <= x && x < -2){
            return 81.0/40.0 + x*(27.0/8.0 + x*(9.0/4.0 + x*(3.0/4.0 + (1.0/8.0 + x/120.0)*x)));
        }else if(1 <= x && x < 2){
            return 17.0/40.0 + x*(5.0/8.0 + x*(-(7.0/4.0) + x*(5.0/4.0 + (-(3.0/8.0) + x/24.0)*x)));
        }else if(-1 <= x && x < 0){
            return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 + x/12.0)*x*x);
        }else{
            return 0;
        }
    };

    BSpline.prototype.getInterpol = function(seq,t){
        var f = this.baseFunc;
        var rangeInt = this.baseFuncRangeInt;
        var tInt = Math.floor(t);
        var result = 0;
        for(var i = tInt - rangeInt;i <= tInt + rangeInt;i++){
            result += seq(i)*f(t-i);
        }
        return result;
    };

    
    BSpline.prototype.calcAt = function(t){
        t = t*((this.degree+1)*2+this.points.length);//t must be in [0,1]
        return {
          lng: this.getInterpol(this.seqAt('lng'),t).toFixed(4),
          lat: this.getInterpol(this.seqAt('lat'),t).toFixed(4)
        };
    };
    // degree = [2, 5]; factor = [2, 10]
    return function(points, degree, factor){
      degree = degree || 4;
      var len = points.length;
      var num = len * (factor || 5);
      num < 20 && (num = 20);
      // console.log('factor = '+factor+', len = '+len +', num = '+num+', degree = '+degree);
      var spline = new BSpline(points, degree, true);
      var points_return = [];
      var space = 1/num;
      for(var t = 0; t <= 1; t += space){
        var interpol = spline.calcAt(t);
        points_return.push(interpol);
      }
      return points_return;
    }
  })();
  var dealItems = (function(){
    var MIN_DIS = Math.pow(0.2, 2);

    return function(items){
      var startPoint = items[0];
      var items_new = [startPoint];
      for(var i = 1, j = items.length; i<j; i++){
        var item = items[i];
        if(Math.pow(startPoint.lng - item.lng, 2) + Math.pow(startPoint.lat - item.lat, 2) > MIN_DIS){
          items_new.push(item);
          startPoint = item;
        }
      }
      return smoothBSpline(items_new, 5);
    }
  })();
  var DEFAULT_VALUE = 999999;
  var ILLEGAL_DISTANCE = Math.pow(50, 2);
  function conrec(rasterData, blendent, is_grid){
    var zArr = [];
    var colors = blendent[0].colors;
    colors.map(function(v){
      if(!v.is_checked){
        return;
      }
      var val = v.val;
      if(zArr.indexOf(val[0]) == -1){
        zArr.push(val[0]);
      }
      if(zArr.indexOf(val[1]) == -1){
        zArr.push(val[1]);
      }
    });
    if(zArr[0] < -100){
      zArr.shift();
    }
    if(zArr[zArr.length-1] > 100){
      zArr.pop();
    }
    var xArr = [], yArr = [];
    rasterData.map(function(v){
      xArr.push(v[0].x);
    });
    rasterData[0].map(function(v){
      yArr.push(v.y);
    });
    sortEsc(xArr);
    sortEsc(yArr);
    sortEsc(zArr);
    var v_split = zArr[0]*2 - zArr[1];

    var arr_compare = [];
    zArr.map(function(v, i){
      // if(v === 0){
      //   zArr[i] = 0.01;
      // }
      // zArr[i] += 1;
      arr_compare.push([v, 0, 0]);
    });
    var data_new = [];
    var len = rasterData.length;
    var num_total = len*rasterData[0].length, num_interpolation_part = 0;
    var is_big_grid = Math.abs(rasterData[0][0].x - rasterData[1][0].x) > 0.5;
    var min_val = DEFAULT_VALUE, max_val = -DEFAULT_VALUE;
    var val_cache = {};
    for(var i = 0; i<len; i++){
      var items = rasterData[i];
      var arr = [];
      for(var i_1 = 0, j_1 = items.length; i_1<j_1; i_1++){
        var val;
        if(i == 0 || i == j-1 || i_1 == 0 || i_1 == j_1 - 1){
          val = -DEFAULT_VALUE;
        }else{
          var v_current = items[i_1].v;
          val = v_current;
          if(v_current == DEFAULT_VALUE){
            val = v_split;
            num_interpolation_part++;
          }else{
            if(val < min_val){
              min_val = val;
            }
            if(val > max_val){
              max_val = val;
            }
            // 记录每个等值线两侧值个数
            arr_compare.forEach(function(v_compare){
              v_compare[v_compare[0] > v_current?1: 2]++;
            });
          }
          if(val_cache[val]){
            val_cache[val]++;
          }else{
            val_cache[val] = 1;
          }
        }
        
        arr.push(val);
      }
      data_new.push(arr);
    }
    var val_arr = [];
    for(var i in val_cache){
      val_arr.push({
        v: i,
        n: val_cache[i]
      });
    }
    val_arr.sort(function(a, b){
      var c = a.v - b.v;
      if(c == 0){
        return a.n - b.n;
      }
      return c;
    });

    if(zArr[0] == 0){
      zArr[0] = 0.01;
    }
    // if(zArr[0] == min_val){
    //   zArr[0] = Math.min((zArr[1] - zArr[0])/10, 1);
    // }
    console.log(val_arr);
    console.log('num_interpolation_part = '+num_interpolation_part+', num_total = '+num_total);
    var is_interpolation_part = num_interpolation_part/num_total > 0.1;
    var is_reverse_split = false;
    var num_big = 0, num_total = 0;
    arr_compare.forEach(function(v_compare){
      var _v_split = v_compare[0];
      if(_v_split >= min_val && _v_split <= max_val){
        if(v_compare[1] < v_compare[2]){
          num_big++;
        }
        num_total++;
      }
    });
    console.log('min_val = '+min_val+', max_val = '+ max_val+', num_big = '+ num_big+', num_total = '+num_total, arr_compare);
    console.log('is_grid = '+is_grid);

    //不是原生格点数据时处理
    if(!is_grid){// && zArr[0] <= min_val
      // 确定添加默认值(一般情况是值越大面积越小，即：小值包含大值；但有些特殊情况如相对湿度就是相反，温度越小越干燥)
      if(num_big/num_total >= 0.5){
        is_reverse_split = true;
        var oldV = v_split;
        v_split = zArr[zArr.length-1]*2 - zArr[zArr.length-2];
        zArr.push(v_split);
      }else{
        zArr.unshift(v_split);
      }
    }
    console.log('is_reverse_split = '+is_reverse_split);

    //重置默认数据
    if(is_reverse_split){
      // v += Math.abs(zArr[zArr.length-1] - zArr[zArr.length-2])*0.2;
      for(var i = 0, j = data_new.length; i<j; i++){
        var items = data_new[i];
        for(var i_1 = 0, j_1 = items.length; i_1<j_1; i_1++){
          if(items[i_1] == oldV){
            items[i_1] = v_split;
          }
        }
      }
    }
    // 找出适合当前数据范围的等值线值，以减小计算量
    var max_index = -1, min_index = -1;
    for(var i = 0, j = zArr.length, k = j - 1; i<j && k >= 0 && i<k; i++,k--){
      var max_test = zArr[i];
      if(max_test >= max_val && max_index == -1){
        max_index = i;
      }
      var min_test = zArr[k];
      if(min_test <= min_val && min_index == -1){
        min_index = k;
      }
    }
    if(max_index == -1){
      max_index = j;
    }
    if(min_index == -1){
      min_index = 0;
    }
    zArr = zArr.slice(min_index, max_index <= min_index?min_index+1: max_index);
    // 修复最小值正好和最小等值线值一样，出现不存在面
    if(zArr[0] == min_val && v_split < min_val){
      // zArr[0] = v_split;
      zArr.unshift(v_split);
    }
    if(zArr[zArr.length-1] == max_val & v_split > max_val){
      zArr[zArr.length-1] = v_split;
    }

    console.log('is_interpolation_part = '+is_interpolation_part+', is_big_grid = '+is_big_grid);
    console.log('v_split = '+v_split, 'zArr=', zArr, colors, data_new);
    var c = new Conrec();
    c.contour(data_new, 0, xArr.length-1, 0, yArr.length-1, xArr, yArr, zArr.length, zArr);
    var list = c.contourList();
    // require('fs').writeFile('E:/source/nodejs_project/micaps/view/test/micaps_3/test_area/data/list.json', JSON.stringify(list));
    var list_new = [];
    // var list_no_close = [];
    // list.map(function(v){
    //   var p_first = v[0],
    //     p_end = v[v.length-1];
    //   if(p_first.x != p_end.x || p_first.y != p_end.y){
    //     list_no_close.push(v);
    //   }else{
    //     v.area = Math.abs(getArea(v));
    //     list_new.push(v);
    //   }
    // });

    // var tmp;
    // while((tmp = list_no_close.shift())){
    //   var p_first = tmp[0],
    //     p_end = tmp[tmp.length-1];
    //   var id_first = p_first.x+'_'+p_first.y,
    //     id_end = p_end.x+'_'+p_end.y;

    //   var level_tmp = tmp.level;
    //   for(var i = 0, j = list_no_close.length; i<j; i++){
    //     var item_test = list_no_close[i];
    //     var p_first_test = item_test[0],
    //       p_end_test = item_test[item_test.length-1];
    //     var id_first_test = p_first_test.x+'_'+p_first_test.y,
    //       id_end_test = p_end_test.x+'_'+p_end_test.y;
        
    //     if(item_test.level == level_tmp){
    //       var is_have_same = true;
    //       if(id_first == id_first_test){
    //         tmp.reverse();
    //         tmp = tmp.concat(item_test);
    //       }else if(id_first == id_end_test){
    //         tmp = item_test.concat(tmp);
    //       }else if(id_end == id_first_test){
    //         tmp = tmp.concat(item_test);
    //       }else if(id_end == id_end_test){
    //         tmp.reverse();
    //         tmp = item_test.concat(tmp);
    //       }else{
    //         is_have_same = false;
    //       }
    //       if(is_have_same){
    //         console.log('merge', level_tmp);
    //         list_no_close.splice(i, 1);
    //         j = list_no_close.length;
    //         i--;
    //       }
    //     }
    //   }
    //   console.log('merge num_total', level_tmp);
    //   tmp.area = Math.abs(getArea(tmp));
    //   list_new.push(tmp);
    // }

    list.map(function(v){
      // if(v.level != v_split){
        v.area = Math.abs(getArea(v));
        list_new.push(v);
      // }
    });
    list_new.sort(function(a, b){
      return b.area - a.area;
    });

    // console.log(list_new);
    if(is_interpolation_part){
      var dele_area = list_new.shift(); // 去除面积最大的一个
      var dele_area_id = dele_area.area;
      console.log('dele_area_id = '+dele_area_id);
    }

    var polygons = [];
    for(var i = 0, j = list_new.length; i<j; i++){
      var points = list_new[i];
      if(dele_area_id && (dele_area_id - points.area)/dele_area_id < 0.2){ //排除最大的面
        console.log('dele_area1 = '+points.area);
        continue;
      }
      var level = points.level;
      // 这里暂时排除上添加的等值线形成的岛
      // if(level == v_split){
      //   console.log('dele_area2 = '+v_split, 'level = '+level);
      //   continue;
      // }
      var c_point = null;
      for(var i_c = 0, j_c = colors.length; i_c < j_c; i_c++){
        var color = colors[i_c];
        var c_val = color.val;
        var c_1 = c_val[0], c_2 = c_val[1];
        
        if(color.is_checked && (is_reverse_split? level > c_1 && level <= c_2: level >= c_1 && level < c_2)){
          c_point = color.color;
          break;
        }
      }
      // console.log(c_point, level);
      if(!c_point){ // 没有相应配色的去除
        console.log('noColor', level);
        continue;
      }
      console.log('level = '+ level, 'color = '+c_point);
      var items = [];
      for(var i_p = 0, j_p = points.length; i_p < j_p; i_p++){
        var p = points[i_p];
        items.push({
          lng: p.x,
          lat: p.y
        });
      }
      // 局部插值或4类插值格点间隔较大时进行平滑处理
      items = is_interpolation_part || is_big_grid ? dealItems(items) : items;
      var p_first = items[0],
        p_last = items[items.length-1];
      /*排除大体上是三角形的不合法的面*/
      if(Math.pow(p_first.lng - p_last.lng, 2) + Math.pow(p_first.lat - p_last.lat, 2) < ILLEGAL_DISTANCE){
        polygons.push({
          items: items,
          color: c_point,
          level: level,
          area: points.area
        });
      }
    }
    console.log(polygons);
    return polygons;
  }
  if (typeof exports !== "undefined") {
    exports.conrec = conrec;
  }
}();